\set ON_ERROR_ROLLBACK on
\set ON_ERROR_STOP on
--\unset AUTOCOMMIT
\set PROMPT1 '%[\033]0;psql %x%n@%m:%>:%/\007\033[46m%]%`date +%H:%M` %[\033[1m%]%n@%/ %[\033[31m%]%x%[\033[34m%]%R%[\033[0;46m%]%#%[\033[0m%] '
\set PROMPT2 '%[\033]0;psql %x%n@%m:%>:%/\007\033[46m%]%`date +%H:%M` %[\033[1m%]%n@%/ %[\033[31m%]%x%[\033[34m%]%R%[\033[0;46m%]%#%[\033[0m%] '
\set VERBOSITY verbose
\pset null '(n)'
\timing

\set act 'SELECT datname, procpid, usename, waiting AS wait, date_trunc($$second$$, age(clock_timestamp(), xact_start)) AS xact_age, date_trunc($$second$$, age(clock_timestamp(), query_start)) AS query_age, date_trunc($$second$$, age(clock_timestamp(), backend_start)) AS backend_age, host(client_addr) || $$:$$ || client_port AS client, CASE WHEN procpid = pg_backend_pid() THEN $$:act$$ ELSE current_query END FROM pg_stat_activity;'
\set user_tables 'SELECT CASE WHEN schemaname = $$public$$ THEN $$$$ ELSE schemaname||$$.$$ END || relname AS relname, seq_scan AS seqscan, seq_tup_read AS seqread, idx_scan AS idxscan, idx_tup_fetch AS idxfetch, n_tup_ins AS ins, n_tup_upd AS upd, n_tup_del AS del, n_tup_hot_upd AS hotupd, n_live_tup AS live, n_dead_tup AS dead, date_trunc($$second$$, age(clock_timestamp(), last_vacuum)) AS vacuum, date_trunc($$second$$, age(clock_timestamp(), last_autovacuum)) AS autovacuum, date_trunc($$second$$, age(clock_timestamp(), last_analyze)) AS analyze, date_trunc($$second$$, age(clock_timestamp(), last_autoanalyze)) AS autoanalyze FROM pg_stat_user_tables;'
