\set QUIET on
\set ON_ERROR_ROLLBACK on
\set ON_ERROR_STOP on
--\unset AUTOCOMMIT

\o /dev/null
--SET bytea_output = 'escape';
UPDATE pg_settings SET setting = 'escape' WHERE "name" = 'bytea_output';

\o ~/.psql-version
SHOW server_version;
\o
\set version `sed -ne 's/^ //;3p' ~/.psql-version; rm -f ~/.psql-version`
--\set PROMPT1 '%[\033]0;psql %x%n@%m:%>:%/\007\033[46m%]%`date +%H:%M` %[\033[1m%]%n@%/ %[\033[31m%]%x%[\033[34m%]%R%[\033[0;46m%]%#%[\033[0m%] '
\set PROMPT1 '%`date +%H:%M` %n@%m:%>/%/ %:version: %x%R%# '
--\set PROMPT2 '%[\033]0;psql %x%n@%m:%>:%/\007\033[46m%]%`date +%H:%M` %[\033[1m%]%n@%/ %[\033[31m%]%x%[\033[34m%]%R%[\033[0;46m%]%#%[\033[0m%] '
\set PROMPT2 '%`date +%H:%M` %n@%m:%>/%/ %:version: %x%R%# '
\set VERBOSITY verbose

\pset null '(n)'

\timing
\unset QUIET

\set act 'SELECT datname, procpid, usename, waiting AS wait, date_trunc($$second$$, age(clock_timestamp(), xact_start)) AS xact_age, date_trunc($$second$$, age(clock_timestamp(), query_start)) AS query_age, date_trunc($$second$$, age(clock_timestamp(), backend_start)) AS backend_age, host(client_addr) || $$:$$ || client_port AS client, CASE WHEN procpid = pg_backend_pid() THEN $$:act$$ ELSE current_query END FROM pg_stat_activity ORDER BY 1, 2;'

\set user_tables 'SELECT CASE WHEN schemaname = $$public$$ THEN $$$$ ELSE schemaname||$$.$$ END || relname AS relname, seq_scan AS seqscan, seq_tup_read AS seqread, idx_scan AS idxscan, idx_tup_fetch AS idxfetch, n_tup_ins AS ins, n_tup_upd AS upd, n_tup_del AS del, n_tup_hot_upd AS hotupd, n_live_tup AS live, n_dead_tup AS dead, date_trunc($$second$$, age(clock_timestamp(), last_vacuum)) AS vacuum, date_trunc($$second$$, age(clock_timestamp(), last_autovacuum)) AS autovacuum, date_trunc($$second$$, age(clock_timestamp(), last_analyze)) AS analyze, date_trunc($$second$$, age(clock_timestamp(), last_autoanalyze)) AS autoanalyze FROM pg_stat_user_tables ORDER BY CASE WHEN schemaname = $$public$$ THEN $$AAAA$$ ELSE schemaname||$$.$$ END || relname;'

\set user_indexes 'SELECT CASE WHEN schemaname = $$public$$ THEN $$$$ ELSE schemaname||$$.$$ END || relname AS relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch FROM pg_stat_user_indexes ORDER BY CASE WHEN schemaname = $$public$$ THEN $$AAAA$$ ELSE schemaname||$$.$$ END || relname, indexrelname;'

\set tablesize 'SELECT CASE WHEN schemaname = $$public$$ THEN $$$$ ELSE schemaname||$$.$$ END || relname AS relname, pg_size_pretty (pg_relation_size(relid)) AS size, pg_relation_size(relid) AS size, pg_size_pretty (pg_total_relation_size(relid)) AS total, pg_total_relation_size(relid) AS total, pg_size_pretty (pg_total_relation_size(relid) - pg_relation_size(relid)) AS extra, pg_total_relation_size(relid) - pg_relation_size(relid) AS extra FROM pg_stat_user_tables ORDER BY CASE WHEN schemaname = $$public$$ THEN $$AAAA$$ ELSE schemaname||$$.$$ END || relname;'

\set indexsize 'SELECT CASE WHEN schemaname = $$public$$ THEN $$$$ ELSE schemaname||$$.$$ END || relname AS relname, indexrelname, pg_size_pretty (pg_relation_size(indexrelid)) AS size, pg_relation_size(indexrelid) AS size FROM pg_stat_user_indexes ORDER BY CASE WHEN schemaname = $$public$$ THEN $$AAAA$$ ELSE schemaname||$$.$$ END || relname, indexrelname;'

\set objsize 'SELECT nspname, (SELECT COUNT(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$r$$) AS "r#", (SELECT SUM(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$r$$) AS r, (SELECT COUNT(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$i$$) AS "i#", (SELECT SUM(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$i$$) AS i, (SELECT COUNT(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$S$$) AS "S#", (SELECT SUM(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$S$$) AS "S", (SELECT COUNT(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$v$$) AS "v#", (SELECT COUNT(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$c$$) AS "c#", (SELECT COUNT(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$t$$) AS "t#", (SELECT SUM(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$t$$) AS t, (SELECT COUNT(pg_relation_size(c.oid)) FROM pg_class c WHERE c.relnamespace = n.oid AND relkind = $$f$$) AS "f#" FROM pg_namespace n ORDER BY nspname;'

\set tableio 'SELECT schemaname, relname, heap_blks_read AS heapread, heap_blks_hit AS heaphit, CASE WHEN heap_blks_read >= heap_blks_hit AND heap_blks_hit > 0 THEN ROUND (heap_blks_read::numeric/heap_blks_hit, 1) || $$:1$$ WHEN heap_blks_hit > heap_blks_read AND heap_blks_read > 0 THEN $$1:$$ || ROUND (heap_blks_hit::numeric/heap_blks_read, 1) ELSE NULL END AS heapr, idx_blks_read AS idxread, idx_blks_hit AS idxhit, CASE WHEN idx_blks_read >= idx_blks_hit AND idx_blks_hit > 0 THEN ROUND (idx_blks_read::numeric/idx_blks_hit, 1) || $$:1$$ WHEN idx_blks_hit > idx_blks_read AND idx_blks_read > 0 THEN $$1:$$ || ROUND (idx_blks_hit::numeric/idx_blks_read, 1) ELSE NULL END AS idxr, toast_blks_read AS toastread, toast_blks_hit AS toasthit, CASE WHEN toast_blks_read >= toast_blks_hit AND toast_blks_hit > 0 THEN ROUND (toast_blks_read::numeric/toast_blks_hit, 1) || $$:1$$ WHEN toast_blks_hit > toast_blks_read AND toast_blks_read > 0 THEN $$1:$$ || ROUND (toast_blks_hit::numeric/toast_blks_read, 1) ELSE NULL END AS toastr, tidx_blks_read AS tidxread, tidx_blks_hit AS tidxhit, CASE WHEN tidx_blks_read >= tidx_blks_hit AND tidx_blks_hit > 0 THEN ROUND (tidx_blks_read::numeric/tidx_blks_hit, 1) || $$:1$$ WHEN tidx_blks_hit > tidx_blks_read AND tidx_blks_read > 0 THEN $$1:$$ || ROUND (tidx_blks_hit::numeric/tidx_blks_read, 1) ELSE NULL END AS tidxr FROM pg_statio_user_tables ORDER BY schemaname, relname;'

\set indexio 'SELECT schemaname, relname, indexrelname, idx_blks_read AS idxread, idx_blks_hit AS idxhit, CASE WHEN idx_blks_read >= idx_blks_hit AND idx_blks_hit > 0 THEN ROUND (idx_blks_read::numeric/idx_blks_hit, 1) || $$:1$$ WHEN idx_blks_hit > idx_blks_read AND idx_blks_read > 0 THEN $$1:$$ || ROUND (idx_blks_hit::numeric/idx_blks_read, 1) ELSE NULL END AS idxr FROM pg_statio_user_indexes ORDER BY schemaname, relname, indexrelname;'

\set schemasize 'SELECT schemaname, pg_size_pretty (SUM (pg_relation_size(relid))::bigint) AS size, SUM (pg_relation_size(relid)) AS size, pg_size_pretty (SUM (pg_total_relation_size(relid))::bigint) AS total, SUM (pg_total_relation_size(relid)) AS total, pg_size_pretty (SUM (pg_total_relation_size(relid) - pg_relation_size(relid))::bigint) AS extra, SUM (pg_total_relation_size(relid) - pg_relation_size(relid)) AS extra FROM pg_stat_user_tables GROUP BY schemaname ORDER BY schemaname;'

\set datsize 'SELECT datname, pg_size_pretty (pg_database_size (datname)) AS size, pg_database_size (datname) AS size FROM pg_database WHERE datallowconn ORDER BY 1;'

\set waiting 'SELECT wait.pid AS wait_pid, wait_stm.datname as wait_datname, wait_stm.usename AS wait_usename, wait.locktype AS wait_locktype, wait.mode AS wait_mode, wait.relation::regclass AS wait_table, wait_stm.current_query AS wait_query, other.pid AS other_pid, other_stm.datname AS other_datname, other_stm.usename AS other_usename, other.locktype AS other_locktype, other.mode AS other_mode, other.relation::regclass AS other_table, other_stm.current_query AS other_query, other.granted AS other_granted FROM pg_catalog.pg_locks AS wait JOIN pg_catalog.pg_stat_activity AS wait_stm ON ( wait_stm.procpid = wait.pid) JOIN pg_catalog.pg_locks AS other ON ( ( wait."database" = other."database" AND wait.relation = other.relation) OR wait.transactionid = other.transactionid) JOIN pg_catalog.pg_stat_activity AS other_stm ON ( other_stm.procpid = other.pid) WHERE NOT wait.granted AND wait.pid <> other.pid;'
